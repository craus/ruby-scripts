Спецификация языка Association.

Императивный язык.
Память интерпретатора - это набор ассоциаций (map).
Ключом в ассоциации может быть объект или пара объектов.
Если не было запомнено ничего другого:
  - значением ассоциации от объекта является сам этот объект;
  - значением ассоциации от пары является объект nil.
Выражение языка - всегда объект или пара объектов.
Значение выражения может быть посчитано для чтения или записи.
Чтобы посчитать значение для чтения:
  - если это объект, берётся ассоциация от него;
  - если это пара объектов, для каждого из них считается значение для чтения, затем берётся ассоциация от пары полученных значений.
Чтобы посчитать значение для записи:
  - если это объект, берётся он сам;
  - если это пара объектов, для каждого из них считается значение для чтения, затем берётся полученная пара значений.
Заметим, что значение для чтения - всегда один объект. Это и есть значение выражения в привычном смысле.
Значение для записи - это место для хранения объекта. Это может быть как объект, так и пара объектов.
  
Единственная операция изменения памяти - присваивание. 
Она принимает выражение и значение, которое нужно присвоить этому выражению.
Чтобы присвоить выражению значение, считается его значение для записи. 
Это и есть место в памяти, которое будет переписано.
Объект, лежащий в этом месте перед присваиванием, будет оттуда удалён.
Каждый раз, когда речь идёт о значении выражения, имеется в виду его значение для чтения, кроме случая присваивания этому выражению.
Присваивание выполняется только при исполнении команды read и команды присваивания.
  
Программа - последовательность команд.
Каждая команда на отдельной строке.
Есть следующие виды команд:
  1) чтение: read <expression>. Читает один бит с потока ввода, присваивает указанному выражению значение 0, 1 или nil, если ввод завершён.
  2) запись: write <expression>. Если значение указанного выражения 0 или 1, выводит в поток вывода соответствующий бит.
  3) создание нового объекта: new <expression>. Создаёт новый объект и присваивает указанному выражению.
  4) безусловный переход: goto <expression>. Об этом поподробнее:
    Каждая команда может иметь метку. 
    Она пишется через двоеточие перед командой, в той же строке. 
    Метка - это некоторое выражение.
    Строка программы с точки зрения интерпретатора - объект. 
    И этот объект может быть значением некоторого выражения.
    Весь смысл меток - это единственная возможность присвоить какому-то выражению значение "некоторая строка программы".
    Перед выполнением программы всем меткам, как выражениям, присваиваются как значения строки, которые помечены этими метками.
    Команда goto <expression> перемещает управление на строку, являющуюся значением выражения. 
    Если значение выражения не является строкой программы, возникнет ошибка "No line associated to '<expression>'".
  5) присваивание: <expression> = <expression>. Правая часть считается для чтения и присваивается левой.
  6) выход: exit. Немедленно завершает выполнение.

Форма Бэкуса-Наура:

<program> ::= <empty string> | <line>\n<program>
<line> ::= <command> | <label>:<command>
<command> ::= read <expression> | write <expression> | new <expression> | goto <expression> | <expression> = <expression> | exit
<expression> ::= <identifier> | <identifier> <identifier>
<label> ::= <expression>
<identifier> ::= <identifier_symbol> | <identifier_symbol><identifier>
<identifier_symbol> ::= [a-z0-9_]

Работа с интерпретатором.
Чтобы запустить программу из консоли:
run <имя файла> <флажки через пробел>
Флажки:
  b. Бинарный режим. 
    Вместо бита 0 или 1 будет читаться и писаться в потоки ввода/вывода символ 0 или 1, соответственно. 
    Если считан символ, отличный от 0 или 1, поток ввода будет считаться завершённым.
  bi. Бинарный режим только для чтения (запись продолжит выполняться побитово).
  bo. Бинарный режим только для записи.
  d. Дебаг. Будет выводиться куча информации о ходе выполнения программы.
  
Примеры программ:
  Вывод бита 0:
    write 0
  Заметим, что 0 здесь - это выражение, которое будет посчитано для чтения.
  Так как это один объект, а не пара, будет взята ассоциация от него.
  Поскольку про объект 0 ничего не запомнено, значение ассоциации - сам объект 0.
  Поэтому будет выведен 0.
  
  Вывод того же бита, который был введён:
    read x
    write x
  Заметим, что в 1-й строке х - выражение, которое будет посчитано для записи.
  Так как это один объект, будет взят сам этот объект.
  В результате выполнения команды read будет запомнена ассоциация (x => 0), если считан бит 0, и (x => 1), если считан бит 1.
  Во 2-й строке х - выражение, которое будет посчитано для чтения. 
  Так как это один объект, будет взята ассоциация от него. 
  Это тот бит, что был прочитан со ввода.
  Поэтому он же и будет выведен.
  
  Вывод бита, противоположного введённому:
    not 1 = 0
    not 0 = 1
    read x
    write not x
  В первых двух строках выполняется два присваивания. Рассмотрим, например, первую.
  В левой части выражение not 1, которое будет посчитано для записи.
  Для этого not будет посчитано для чтения. Поскольку про него ничего не запомнено, получится сам объект not.
  1 будет также посчитано для чтения и получится 1.
  Затем в качестве значения выражения для записи будет взята пара [not, 1].
  В правой части выражение 0, значение его для чтения - 0.
  В результате присваивания будет запомнена ассоциация ([not, 1] => 0).
  Во второй строке будет запомнена ассоциация ([not, 0] => 1).
  В третьей строке будет запомнена ассоциация (x => 0), если считан бит 0, и (x => 1), если считан бит 1. Пусть к примеру считан 0.
  В четвёрной строке будет найдено значение выражения not x для чтения.
  Для этого будут посчитаны для чтения not и х. 
  Выяснится, что про not ничего не запомнено и его значение для чтения - сам объект not.
  А про х выяснится, что про него запомнено (x => 0). Значит, его значение для чтения - 0.
  Затем будет посчитана ассоциация от пары полученных значений: [not 0]. Про эту пару было запомнено 1. 
  Поэтому значением not x для чтения будет 1.
  Именно этот бит и уйдёт на печать.
  
  Клонирование всего потока ввода в поток вывода:
    readed 1 = readed 0
    reading: read x
    goto readed x
    readed 0: write x
    goto reading
    readed nil: exit
  В этой программе есть метки. 
  Поэтому перед выполнением программы метки будут посчитаны для записи.
  При этом будут созданы ассоциации reading со 2-й строкой программы, [readed 0] с 4-й, и [readed nil] с 6-й.
  Затем программа начнёт выполняться.
  В первой строке readed 1 будет присвоено readed 0. Значение readed 0 - четвёртая строка программы, поэтому будет создана ассоциация [readed 1] => <4-я строка>.
  Во второй строке х примет значение бита со ввода.
  В третьей строке будет выполнен переход на строку, являющуюся значением выражения readed x. 
  Если был считан бит 0 или 1, значение х для чтения будет 0 или 1, значение readed x для чтения будет 4-й строкой. 
  Поэтому управление будет передано 4-й строке.
  Если поток ввода завершился, х будет равен nil, значение readed x для чтения будет как и у readed nil - шестой строкой. 
  Поэтому управление будет передано 6-й строке и программа завершится.
  В четвёртой строке значение х будет отправлено в поток вывода. 
  Затем в пятой строке будет осуществлён переход на строку reading - вторую и пойдёт копироваться следующий символ.
  Так будет продолжаться пока не будет считано nil, т.е. до конца ввода.
  
  Побитовый разворот потока ввода:
    readed 1 = readed 0
    current 1 = current 0
    reading: read x
    goto readed x
5   readed 0: new y
    y data = x
    y next = stack
    stack = y
    goto reading
10  readed nil: sym = stack data
    goto current sym
    current 0: write stack data
    stack = stack next
    goto readed nil
    current nil: exit
  Основной идеей программы является создание стека. 
  Стек - это стопка объектов, каждый из которых (node), кроме нижнего, знает ссылку на следующего снизу (node next), и 1 бит данных (node data).
  Объект stack - это верхний элемент стека.
  Перед выполнением и в начале программы, в первых 2 строках, будут созданы метки:
    readed 1, readed 0 - строка 5.
    current 1, current 0 - строка 11.
    reading - строка 3.
    readed nil: строка 10.
  Перед выполнением программы stack - просто некоторый объект, с которым нет никаких ассоциаций.
  Строки с 3 по 9 образуют цикл чтения. 
  На каждой итерации, если поток ввода завершился, цикл завершается.
  Иначе, в стек кладётся новый элемент. Происходит это так:
    Создаётся новый объект и кладётся в переменную y. 
      С точки зрения языка, в качестве ассоциации с объектом y записывается новый объект.
    Создаются две ассоциации: y data - прочитанный символ, и y next - верхний элемент стека.
    Затем присваивается stack = y. Теперь объект y признан верхним элементом стека. 
      При этом мы теряем доступ к старому верхнему элементу стека через переменную stack.
      Чтобы обратиться к неверхнему элементу стека, надо сказать stack next - для второго элемента стека.
      А к третьему и далее элементу вообще никак нельзя обратиться без дополнительной переменной.
  После чтения всего ввода этот ввод запихан в стек, и мы на 10-й строке.
  Строки с 10 по 14 образуют цикл записи.
  В 10-й строке в переменную sym кладётся бит, хранящийся в вершине стека. 
  Если стек пуст, значение выражения stack data для записи будет ассоциацией двух объектов - изначального stack и какого-то data. 
  Такой ассоциации не запомнено, и результатом будет по умолчанию nil.
  В 11-й строке, если sym равен nil, делается вывод, что стек пуст, и осуществляется переход на 15-ю строку и завершение программы.
  Иначе, в 12-й строке хранимый в вершине стека бит распечатывается.
  В 13-й строке вершине стека присваивается его второй элемент. 
  Так происходит удаление верхнего элемента из стека. 
  К нему теперь вообще никак нельзя получить доступ.
  Но он будет лежать и засорять память, т.к. сборщик мусора к этому языку ещё никто не придумал.
  После чего цикл повторяется вплоть до опустошения стека.
  В процессе работы биты выводятся в порядке, обратном вводу.